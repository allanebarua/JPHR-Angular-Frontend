{"version":3,"file":"persistence.cached_service.js","sourceRoot":"","sources":["../../../src/abstracts/persistence.cached_service.ts"],"names":[],"mappings":"AASA;;;;;;;;;;;;;;GAcG;AACH;IAAA;IA6EA,CAAC;IA5ED;;;;;;;;;;;;;OAaG;IACI,uCAAO,GAAd;QACQ,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,OAAO,EAAE,CAAC;IACrC,CAAC;IACL;;;;;;;;;;;OAWG;IACI,mCAAG,GAAV;QACQ,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,CAAC;IACjC,CAAC;IACL;;;;;OAKG;IACI,qCAAK,GAAZ;QACQ,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,CAAC;IACnC,CAAC;IACL;;;;;;;;OAQG;IACI,uCAAO,GAAd,UAAe,KAA6B,EAAE,KAA0B;QAChE,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;IACtB,CAAC;IACL;;;;;;;;OAQG;IACI,2CAAW,GAAlB,UAAmB,KAA6B,EAAE,KAA0B;QACpE,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,UAAC,GAAG,IAAK,OAAA,GAAG,GAAG,IAAI,GAAG,KAAK,EAAlB,CAAkB,CAAC,CAAC;IACvD,CAAC;IACL;;;;;;;;;OASG;IACH,wCAAQ,GAAR,cAAY,CAAC;IACb,4BAAC;AAAD,CAAC,AA7ED,IA6EC","sourcesContent":["import {\n    ActivatedRouteSnapshot,\n    CanActivate,\n    Resolve,\n    RouterStateSnapshot\n    } from '@angular/router';\nimport { ConnectableObservable, Observable } from 'rxjs';\nimport { ICache } from './persistence.cache';\nimport { PersistenceService } from '../services/persistence.service';\n/**\n * This is a cache that also implements the <code>CanActivate</code> and <code>Resolve<T></code> \n * interfaces in angular so that it can be used as both a provider and a set of guards for Angular\n * routing.  By implementing the abstract <code>getCache<T></code> method using a cache object, \n * this abstract class can form the foundation for a service based off of the persistence framework.\n * \n * @export\n * @abstract\n * \\@class AbstraceCachedService\n * @template T - the type of value returned by this service.\n * \n * @author Scott O'Bryan\n * \\@since 1.0\n * @abstract\n */\nexport abstract class AbstractCachedService<T> implements ICache<T>, CanActivate, Resolve<T> {\n/**\n * Returns an {Observable<T>} which will monitor changes to the \n * cache over a period of time.  This is a hot, multi-value \n * observable which will emit the cached value, if one exists,\n * when the Observable is first subscribed to.  The observer will\n * then emit a new event each time the cache changes.\n * \n * As this is a multi-value observer which is not expected to\n * complete, it is the responsiblity of the subscriber to\n * unsubscribe in order to prevent potential memory leaks.\n * \n *          the value in the cache changes\n * @return {?}\n */\npublic changes(): Observable<T> {\n        return this.getCache().changes();\n    }\n/**\n * Returns an {Observable<T>} to a cached value if one is loaded \n * or to the value specified by the loader that was supplied when \n * this cache was created if it is not.\n * \n * This Observable is guarenteed to be a single observable which\n * means it returns a single value before it completes.  As such\n * you do not have to unsubscribe from this Observable.\n * \n *          value.\n * @return {?}\n */\npublic get(): Observable<T> {\n        return this.getCache().get();\n    }\n/**\n * Manually clears the value in the cache forcing a reload.\n * \n * @abstract\n * @return {?}\n */\npublic clear(): void {\n        return this.getCache().clear();\n    }\n/**\n * Returns the observable to the current cached service for use in the angular Router.\n * This is equivalent to the get method but implements the resolve interface for the\n * Angular Router.\n * \n * @param {?} route\n * @param {?} state\n * @return {?}\n */\npublic resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<T> {\n        return this.get();\n    }\n/**\n * Returns true if the value of the cached observable is \"truthy\" and false if it is not.\n * \n * \n * \\@memberOf AbstraceCachedService\n * @param {?} route\n * @param {?} state\n * @return {?}\n */\npublic canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> {\n        return this.get().map((val) => val ? true : false);\n    }\n/**\n * Returns a cache that this service will use to return values.  The Cache may be obtained\n * from the PersistenceService or it may be a custom implementation should one be needed.\n * \n * @protected\n * @abstract\n * @template T \n * @abstract\n * @return {?}\n */\ngetCache() {}\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}