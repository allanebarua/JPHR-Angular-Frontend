{"version":3,"file":"persistence.cache.js","sourceRoot":"","sources":["../../../src/abstracts/persistence.cache.ts"],"names":[],"mappings":"","sourcesContent":["import { Observable } from 'rxjs/Rx';\n\n/**\n * A caching system that uses the Angular Persistence framework for storage.\n * A cache is a persistence store that contains a single attribute value.  This\n * value is automatically reloaded when the cache no longer contains any values\n * either through some sort of expiration or by manually clearing the value\n * via the <codel>Cache.clear</code> method.  Cache's support expireAfter and Timeout\n * configuration options and may be stored in any of the persistent data stores.\n *   \n * To get ahold of this cache, use <code>PersistenceService.createCache</code>.\n * \n * @export\n * @interface ICache\n * @template T - they type of value contained in the cache.\n * \n * @author Scott O'Bryan\n * @since 1.0\n */\nexport interface ICache<T> {\n\n    /**\n     * Returns an Observable to a cached value if one is loaded or to the \n     * value specified by the loader that was supplied when this cache was \n     * created if it is not.\n     * \n     * This Observable is guarenteed to be a single observable which\n     * means it returns a single value before it completes.  As such\n     * you do not have to unsubscribe from this Observable.\n     * \n     * @returns {Observable<T>} of type T that will contain the\n     *          value. \n     */\n    get(): Observable<T>;\n\n    /**\n     * Returns an Observable which will monitor changes to the cache \n     * over a period of time.  This is a hot, multi-value observable which \n     * will emit the cached value, if one exists, when the Observable is \n     * first subscribed to.  The observer will then emit a new event each \n     * time the cache changes.\n     * \n     * As this is a multi-value observer which is not expected to complete, \n     * it is the responsiblity of the subscriber to unsubscribe in order to \n     * prevent potential memory leaks.\n     * \n     * @returns {Observable<T>} which will emit an event whenever\n     *          the value in the cache changes\n     */\n    changes(): Observable<T>;\n\n\n    /**\n     * Manually clears the value in the cache forcing a reload.\n     */\n    clear(): void;\n\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}