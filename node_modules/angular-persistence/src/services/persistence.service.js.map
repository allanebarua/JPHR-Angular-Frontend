{"version":3,"file":"persistence.service.js","sourceRoot":"","sources":["../../../src/services/persistence.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable, EventEmitter } from '@angular/core';\nimport { Observable, Observer, Subscriber, Subject } from 'rxjs';\nimport { CacheImpl } from './persistence.cache-impl';\nimport { IStorage } from './storage/storage.interface';\nimport { SubStorage } from './storage/storage.sub_storage';\nimport { StorageFactory } from './storage/storage.factory';\nimport { StorageType } from '../constants/persistence.storage_type';\nimport { PersistenceConfig } from '../types/persistence.config';\nimport { ItemDefinition } from '../types/persistence.item_definition';\nimport { CacheConfig } from '../types/persistence.cache_config';\nimport { IPersistenceContainer } from '../abstracts/persistence.container';\nimport { ICache } from '../abstracts/persistence.cache';\n/**\n * Service used to persist application wide storage.  Iterms may be obtained from the Service\n * itself or used through proxies.  This framework also supports an immutable flag which will\n * instruct the service that the objects stored within should not have any side-effects when\n * objects on the outside are changed.\n * \n * Note on immutability: Only clonable objects will be saved when the immutable flag is\n * set.  This framework will do a deep clone of the objects in question, but items such\n * as functions will not be preserved.  Also, immutability is slower.  If you have objects\n * that are well controlled with a single component, it is suggested that you don't save your\n * item as immutable.\n * \n * @export\n * \\@class PersistenceService\n * \n * @author Scott O'Bryan\n * \\@since 1.0\n */\nexport class PersistenceService {\nprivate _emitter = new EventEmitter<ItemDefinition>();\nprivate _storage: StorageFactory = StorageFactory.getStorage();\n/**\n * Returns a hot observable that can be used to monitor changes to this framework over\n * time.  Subscribing to this observable has the potential of causing memory leaks,\n * so each subscriber is expected to unsubscribe when notifications are no longer\n * needed.\n * \n *                                  results.  If not provided, all changes will be\n *                                  returned.\n * \n *                                  to this framework over time.\n * @param {?=} config\n * @return {?}\n */\npublic changes(config: ItemDefinition = {}): Observable<ItemDefinition> {\n        let /** @type {?} */ observable = this._emitter.asObservable();\n\n        // apply the key filter\n        if (config.key) {\n            observable = observable.filter((val) => val.key === config.key);\n        }\n\n        // apply the type filter\n        if (config.type) {\n            observable = observable.filter((val) => val.type === config.type);\n        }\n\n        return observable;\n    }\n/**\n * Returns an object from storage.  If the object was stored with the immutable flag\n * set, then the object returned will not have any side-effects into the stored model\n * until it is set again.\n * \n * @param {?} key\n * @param {?=} type\n * @return {?}\n */\npublic get(key: string, type: StorageType = StorageType.MEMORY): any {\n        let /** @type {?} */ storage = this._getStorage(type);\n        let /** @type {?} */ value = storage.get(key);\n\n        // the value here will actually be an object with some metadata attached.  This\n        // is done to handle immutable and some other things.\n        if (value) {\n            let /** @type {?} */ currDate = Date.now();\n\n            // if we have a value, we need to check to see if its expired.\n            if (value.expireAfter && value.created + value.expireAfter < currDate ) {\n                storage.remove(key);\n                this._emitter.emit({ key, type });\n                return undefined;\n            }\n\n            // handle the oneUse configuration\n            if ( value.oneUse ) {\n                storage.remove(key);\n                this._emitter.emit({ key, type });\n                return value.data;\n            }\n\n            // if maxAge then we need to update the expires tag\n            if ( value.timeout ) {\n                if ( value.lastAccessed + value.timeout < currDate ) {\n                    storage.remove(key);\n                    this._emitter.emit({ key, type });\n                    return undefined;\n                } else {\n                    value.lastAccessed = currDate;\n                    storage.set(key, value);\n                }\n            }\n\n            return value.data;\n        }\n\n        return undefined;\n    }\n/**\n * Puts an object into storage, replacing any item that may be in there.  By default, \n * the object is stored as-is, which means that when other areas of code get the \n * object, they can mutate it.\n * \n * As immutable storage is slower, and the reconstituted logic may be\n * missing functions or metadata, it is recommended to use this only\n * if you need to ensure the integrity of the stored object on each set\n * as might be the case if you make use of the \"change\" emitter.\n * \n * @param {?} key\n * @param {?} value\n * @param {?=} config\n * @return {?}\n */\npublic set( key: string, value: any, config: PersistenceConfig = {}): boolean {\n            \n        if (!config.type) {\n            config.type = StorageType.MEMORY;\n        }\n\n        if (!value === undefined) {\n            this.remove(key);\n            this._emitter.emit({key, type: config.type});\n            return true;\n        }\n\n        let /** @type {?} */ storage = this._getStorage(config.type);\n\n        let /** @type {?} */ currDate = Date.now();\n        let /** @type {?} */ success = storage.set(key, {\n            data: value,\n            expireAfter: config.expireAfter,\n            timeout: config.timeout,\n            oneUse: config.oneUse ? true : false,\n            created: currDate,\n            lastAccessed: currDate\n        });\n\n        // happens if the info object or storage object cannot be saved.\n        // Ensure we have cleaned up.\n        if (success) { \n\n             // this seems kind of wierd, but if we are using an immutable \n             // storage type, we want the emitter\n            this._emitter.emit({key, type: config.type});\n        } else {\n            storage.remove(key);\n        }\n\n        return success;\n    }\n/**\n * Clears a value stored in the service for the given type.\n * \n * @param {?} key\n * @param {?=} type\n * @return {?}\n */\npublic remove(key: string, type: StorageType = StorageType.MEMORY): any {\n        let /** @type {?} */ storage = this._getStorage(type);\n        let /** @type {?} */ currentItem = this.get(key, type);\n        if (currentItem !== undefined) {\n            storage.remove(key);\n            this._emitter.emit({key, type});\n        }\n        return currentItem;\n    }\n/**\n * Clears all stored items for a particular storage type.\n * \n * @param {?=} type\n * @return {?}\n */\npublic removeAll(type: StorageType = StorageType.MEMORY): void {\n        let /** @type {?} */ keys = this._getStorage(type).keys();\n        this._getStorage(type).removeAll();\n        keys.forEach((key: string) => this._emitter.emit({key, type}));\n    }\n/**\n * Cleans up any expired objects in the cache.\n * \n * @param {?=} type\n * @return {?}\n */\npublic clean(type: StorageType = StorageType.MEMORY): void {\n        let /** @type {?} */ storage = this._getStorage(type);\n        let /** @type {?} */ keys = storage.keys();\n        let /** @type {?} */ currDate = Date.now();\n\n        for (let /** @type {?} */ key of keys) {\n            let /** @type {?} */ item = storage.get(key);\n            // if we have a value, we need to check to see if its expired.\n            if (item && \n                (\n                    (item.expireAfter && item.created + item.expireAfter < currDate ||\n                    item.timeout && item.lastAccessed + item.timeout < currDate)\n                )\n            ) {\n                this.remove(key);\n            }\n        }\n    }\n/**\n * Create a property on the object that is bound to this stored value.  This method\n * requires ES5 compatibility and the property will have special rules associated \n * with it.  The name of the property will be \"key\", and the value stored in the\n * configured storage will be prefix + key.\n * \n * @template T the type of property\n * @param {?} obj\n * @param {?} propName\n * @param {?} key\n * @param {?=} config\n * @return {?}\n */\npublic defineProperty<T> (obj: any, propName: string, key: string, config: PersistenceConfig = {}): void {\n        let /** @type {?} */ type = config.type || StorageType.MEMORY;\n\n        Object.defineProperty(obj, propName, {\n            enumerable: true,\n            configurable: true,\n            get: (): T => { return this.get(key, type); },\n            set: (val: T): void => { this.set(key, val, config); }\n        });\n    }\n/**\n * Returns a facade that makes things a bit easier when interacting with the service.\n * The facade will use the prefix in order to isolate they keystore.  If no prefix is\n * defined, the keystore will be mapped as usual with the keys working as-is in the\n * storage.\n * \n * @param {?} namespace\n * @param {?=} config the config for the facade\n * @return {?} a PersistenceFacade object representing this store\n */\npublic createContainer(namespace: string, config: PersistenceConfig = {}): IPersistenceContainer {\n        let /** @type {?} */ thisService = this;\n        let /** @type {?} */ myConfig: PersistenceConfig = {\n            oneUse: config.oneUse,\n            expireAfter: config.expireAfter,\n            timeout: config.timeout,\n            type: config.type || StorageType.MEMORY\n        };\n\n        // Return a substorage of the service so the full config can be used.\n        return new SubStorage(namespace, {\n            get: (key: string): any => {\n                return thisService.get(key, myConfig.type);\n            },\n\n            set: (key: string, value: any): boolean => {\n                return thisService.set(key, value, myConfig);\n            },\n\n            remove: (key: string): any => {\n                return thisService.remove(key, myConfig.type);\n            },\n\n            removeAll: (): void => {\n                return thisService.removeAll();\n            }\n        }, true);\n \n    }\n/**\n * Returns a cache proxy that makes interacting with this service a little bit easier.  The\n * proxy returned will have a set key, a generic loader, and a consistent set of config\n * parameters. Please note that the \"expires\" property of the config might have unforseen\n * side-effects to the cache in that if the expires setting is already passed, the cache will\n * no longer cache values until a new proxy is created.\n * \n * @param {?} key    they key for the item in the persistence layer\n * @param {?} loader the function to load the intiial value.  Must return either a value or \n *               an Observable of that value.  If an observable is returned, it will be\n *               converted into a single by this method and returned to the subscriber.\n * @param {?=} config optional config object used to \"set\" the value if it has not already\n *               been loaded.  If a \"type\" is not specified, memory storage will be \n *               used.  \n * \n * @return {?} a CacheProxy that can be used to interact with this cache.\n */\npublic createCache<T>(\n        key: string,\n        loader: () => T | Observable<T>,\n        config: CacheConfig = {} \n    ): ICache<T> {\n        // for safety ensure that oneUse is not present.  It shouldn't be, but sometimes\n        // typescript doesn't always catch errors\n        let /** @type {?} */ myConfig: CacheConfig = {\n            type: config.type || StorageType.MEMORY,\n            expireAfter: config.expireAfter,\n            timeout: config.timeout\n        };\n\n        return new CacheImpl(key, loader, this, myConfig);\n    }\n/**\n * @param {?} type\n * @return {?}\n */\nprivate _getStorage(type: StorageType): IStorage {\n        return this._storage.of(type);\n    }\n/**\n * @param {?} maxAge\n * @return {?}\n */\nprivate _calculateExpires(maxAge: number) {\n        return maxAge ? Date.now() + maxAge : undefined;\n    }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction PersistenceService_tsickle_Closure_declarations() {\n/** @type {?} */\nPersistenceService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nPersistenceService.ctorParameters;\n/** @type {?} */\nPersistenceService.prototype._emitter;\n/** @type {?} */\nPersistenceService.prototype._storage;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}