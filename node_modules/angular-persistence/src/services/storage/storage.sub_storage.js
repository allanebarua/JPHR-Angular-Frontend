import { ContainerInfo } from './storage.container_info';
/**
 * This is an internal implementation of a storage container.  It takes a PersistenceContainer
 * (which has a subset of the functionality) and straps on an info object to keep track of
 * items that are added to the container.  This class can be used for creating storage
 * containers within other storage containers.
 *
 * @export
 * \@class PersistenceContainerImpl
 *
 * @author Scott O'Bryan
 * \@since 1.0
 */
export var SubStorage = (function () {
    /**
     * Creates an instance of SubStorage.
     * @param {?} _namespace
     * @param {?} _root
     * @param {?=} _available
     */
    function SubStorage(_namespace, _root, _available) {
        if (_available === void 0) { _available = true; }
        this._namespace = _namespace;
        this._root = _root;
        this._available = _available;
        this._info = new ContainerInfo(_namespace, _root);
    }
    /**
     * Sets a value
     *
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    SubStorage.prototype.set = function (key, value) {
        if (!this._available) {
            return false;
        }
        var /** @type {?} */ val = this._root.set(this._getNamespacedKey(key), value);
        this._info.addAttribute(key);
        return val;
    };
    /**
     * Returns a value for a given key
     *
     * @param {?} key
     * @return {?}
     */
    SubStorage.prototype.get = function (key) {
        if (!this._available) {
            return undefined;
        }
        var /** @type {?} */ val = this._root.get(this._getNamespacedKey(key));
        if (val === undefined) {
            this._info.removeAttribute(key);
        }
        return val;
    };
    /**
     * Removes a value for a given key
     *
     * @param {?} key
     * @return {?}
     */
    SubStorage.prototype.remove = function (key) {
        if (!this._available) {
            return undefined;
        }
        this._info.removeAttribute(key);
        return this._root.remove(this._getNamespacedKey(key));
    };
    /**
     * Removes any values which have been stored using this subStorage
     * container.
     * @return {?}
     */
    SubStorage.prototype.removeAll = function () {
        var _this = this;
        this._info.getAttributes().forEach(function (element) { _this.remove(element); });
    };
    /**
     * Returns true if the parent storage object is available and if the
     * available flag was set durring instantiation
     *
     * @return {?}
     */
    SubStorage.prototype.available = function () {
        return this._available && this._info.available();
    };
    /**
     * Returns true if the value is not undefined
     *
     * @param {?} key
     * @return {?}
     */
    SubStorage.prototype.exists = function (key) {
        // This will also make sure the info object is up to date.
        return this.get(key) !== undefined;
    };
    /**
     * Returns a list of un-namespaced keys that have been returned by this object.
     *
     * @return {?}
     */
    SubStorage.prototype.keys = function () {
        var _this = this;
        // The exists will update the underlying storage object because
        // it invokes a get.  Still, we have an attributes object that is
        // not tied to the object in storage, hopefully.
        return this._info.getAttributes().filter(function (key) {
            return _this.exists(key);
        });
    };
    /**
     * @param {?} key
     * @return {?}
     */
    SubStorage.prototype._getNamespacedKey = function (key) {
        return this._namespace + '::' + key;
    };
    return SubStorage;
}());
function SubStorage_tsickle_Closure_declarations() {
    /** @type {?} */
    SubStorage.prototype._info;
    /** @type {?} */
    SubStorage.prototype._namespace;
    /** @type {?} */
    SubStorage.prototype._root;
    /** @type {?} */
    SubStorage.prototype._available;
}
//# sourceMappingURL=storage.sub_storage.js.map